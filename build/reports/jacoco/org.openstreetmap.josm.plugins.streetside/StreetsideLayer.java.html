<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StreetsideLayer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">MicrosoftStreetside</a> &gt; <a href="index.source.html" class="el_package">org.openstreetmap.josm.plugins.streetside</a> &gt; <span class="el_source">StreetsideLayer.java</span></div><h1>StreetsideLayer.java</h1><pre class="source lang-java linenums">// License: GPL. For details, see LICENSE file.
package org.openstreetmap.josm.plugins.streetside;

import java.awt.AlphaComposite;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Composite;
import java.awt.Graphics2D;
import java.awt.GraphicsEnvironment;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.awt.TexturePaint;
import java.awt.geom.Line2D;
import java.awt.geom.Path2D;
import java.awt.image.BufferedImage;
import java.util.Comparator;
import java.util.IntSummaryStatistics;
import java.util.Optional;

import javax.swing.Action;
import javax.swing.Icon;

import org.openstreetmap.josm.Main;
import org.openstreetmap.josm.data.Bounds;
import org.openstreetmap.josm.data.osm.DataSet;
import org.openstreetmap.josm.data.osm.event.DataChangedEvent;
import org.openstreetmap.josm.data.osm.event.DataSetListenerAdapter;
import org.openstreetmap.josm.data.osm.visitor.BoundingXYVisitor;
import org.openstreetmap.josm.gui.MainApplication;
import org.openstreetmap.josm.gui.MapView;
import org.openstreetmap.josm.gui.NavigatableComponent;
import org.openstreetmap.josm.gui.dialogs.LayerListDialog;
import org.openstreetmap.josm.gui.dialogs.LayerListPopup;
import org.openstreetmap.josm.gui.layer.AbstractModifiableLayer;
import org.openstreetmap.josm.gui.layer.Layer;
import org.openstreetmap.josm.gui.layer.LayerManager;
import org.openstreetmap.josm.gui.layer.MainLayerManager.ActiveLayerChangeEvent;
import org.openstreetmap.josm.gui.layer.MainLayerManager.ActiveLayerChangeListener;
import org.openstreetmap.josm.plugins.streetside.cache.CacheUtils;
import org.openstreetmap.josm.plugins.streetside.gui.StreetsideFilterDialog;
import org.openstreetmap.josm.plugins.streetside.gui.StreetsideMainDialog;
import org.openstreetmap.josm.plugins.streetside.history.StreetsideRecord;
import org.openstreetmap.josm.plugins.streetside.io.download.StreetsideDownloader;
import org.openstreetmap.josm.plugins.streetside.io.download.StreetsideDownloader.DOWNLOAD_MODE;
import org.openstreetmap.josm.plugins.streetside.mode.AbstractMode;
import org.openstreetmap.josm.plugins.streetside.mode.JoinMode;
import org.openstreetmap.josm.plugins.streetside.mode.SelectMode;
import org.openstreetmap.josm.plugins.streetside.utils.MapViewGeometryUtil;
import org.openstreetmap.josm.plugins.streetside.utils.StreetsideColorScheme;
import org.openstreetmap.josm.plugins.streetside.utils.StreetsideProperties;
import org.openstreetmap.josm.plugins.streetside.utils.StreetsideUtils;
import org.openstreetmap.josm.tools.I18n;
import org.openstreetmap.josm.tools.ImageProvider.ImageSizes;
import org.openstreetmap.josm.tools.Logging;

import org.openstreetmap.josm.plugins.streetside.gui.StreetsideChangesetDialog;

/**
 * This class represents the layer shown in JOSM. There can only exist one
 * instance of this object.
 *
 * @author nokutu
 */
public final class StreetsideLayer extends AbstractModifiableLayer implements
ActiveLayerChangeListener, StreetsideDataListener {

	/** The radius of the image marker */
	private static final int IMG_MARKER_RADIUS = 7;
	/** The radius of the circular sector that indicates the camera angle */
	private static final int CA_INDICATOR_RADIUS = 15;
	/** The angle of the circular sector that indicates the camera angle */
	private static final int CA_INDICATOR_ANGLE = 40;
	/** Length of the edge of the small sign, which indicates that traffic signs have been found in an image. */
	private static final int TRAFFIC_SIGN_SIZE = 6;
	/** A third of the height of the sign, for easier calculations */
<span class="fc" id="L77">	private static final double TRAFFIC_SIGN_HEIGHT_3RD = Math.sqrt(</span>
<span class="fc" id="L78">			Math.pow(StreetsideLayer.TRAFFIC_SIGN_SIZE, 2) - Math.pow(StreetsideLayer.TRAFFIC_SIGN_SIZE / 2d, 2)</span>
			) / 3;

<span class="fc" id="L81">	private static final DataSetListenerAdapter DATASET_LISTENER =</span>
			new DataSetListenerAdapter(e -&gt; {
<span class="nc bnc" id="L83" title="All 4 branches missed.">				if (e instanceof DataChangedEvent &amp;&amp; StreetsideDownloader.getMode() == DOWNLOAD_MODE.OSM_AREA) {</span>
					// When more data is downloaded, a delayed update is thrown, in order to
					// wait for the data bounds to be set.
<span class="nc" id="L86">					MainApplication.worker.execute(StreetsideDownloader::downloadOSMArea);</span>
				}
<span class="nc" id="L88">			});</span>

	/** Unique instance of the class. */
	private static StreetsideLayer instance;
	/** The nearest images to the selected image from different sequences sorted by distance from selection. */
<span class="nc" id="L93">	private StreetsideImage[] nearestImages = {};</span>
	/** {@link StreetsideData} object that stores the database. */
	private final StreetsideData data;

	/** Mode of the layer. */
	public AbstractMode mode;

	private volatile TexturePaint hatched;
<span class="nc" id="L101">	private final StreetsideLocationChangeset locationChangeset = new StreetsideLocationChangeset();</span>

	private StreetsideLayer() {
<span class="nc" id="L104">		super(I18n.tr(&quot;Microsoft Streetside Images&quot;));</span>
<span class="nc" id="L105">		data = new StreetsideData();</span>
<span class="nc" id="L106">		data.addListener(this);</span>
<span class="nc" id="L107">	}</span>

	/**
	 * Initializes the Layer.
	 */
	private void init() {
<span class="nc" id="L113">		final DataSet ds = MainApplication.getLayerManager().getEditDataSet();</span>
<span class="nc bnc" id="L114" title="All 2 branches missed.">		if (ds != null) {</span>
<span class="nc" id="L115">			ds.addDataSetListener(StreetsideLayer.DATASET_LISTENER);</span>
		}
<span class="nc" id="L117">		MainApplication.getLayerManager().addLayer(this);</span>
<span class="nc" id="L118">		MainApplication.getLayerManager().addActiveLayerChangeListener(this);</span>
<span class="nc bnc" id="L119" title="All 2 branches missed.">		if (!GraphicsEnvironment.isHeadless()) {</span>
<span class="nc" id="L120">			setMode(new SelectMode());</span>
<span class="nc bnc" id="L121" title="All 2 branches missed.">			if (StreetsideDownloader.getMode() == DOWNLOAD_MODE.OSM_AREA) {</span>
<span class="nc" id="L122">				StreetsideDownloader.downloadOSMArea();</span>
			}
<span class="nc bnc" id="L124" title="All 2 branches missed.">			if (StreetsideDownloader.getMode() == DOWNLOAD_MODE.VISIBLE_AREA) {</span>
<span class="nc" id="L125">				mode.zoomChanged();</span>
			}
		}
		// Does not execute when in headless mode
<span class="nc bnc" id="L129" title="All 4 branches missed.">		if (Main.main != null &amp;&amp; !StreetsideMainDialog.getInstance().isShowing()) {</span>
<span class="nc" id="L130">			StreetsideMainDialog.getInstance().showDialog();</span>
		}
<span class="nc bnc" id="L132" title="All 2 branches missed.">		if (StreetsidePlugin.getMapView() != null) {</span>
<span class="nc" id="L133">			StreetsideMainDialog.getInstance().getStreetsideImageDisplay().repaint();</span>
			/*StreetsideMainDialog.getInstance()
			.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW)
			.put(KeyStroke.getKeyStroke(&quot;DELETE&quot;), &quot;StreetsideDel&quot;);
			StreetsideMainDialog.getInstance().getActionMap()
			.put(&quot;StreetsideDel&quot;, new DeleteImageAction());*/

			// There is no delete image action for Streetside

<span class="nc" id="L142">			getLocationChangeset().addChangesetListener(StreetsideChangesetDialog.getInstance());</span>
		}
<span class="nc" id="L144">		createHatchTexture();</span>
<span class="nc" id="L145">		invalidate();</span>
<span class="nc" id="L146">	}</span>

	public static void invalidateInstance() {
<span class="pc bpc" id="L149" title="1 of 2 branches missed.">		if (StreetsideLayer.hasInstance()) {</span>
<span class="nc" id="L150">			StreetsideLayer.getInstance().invalidate();</span>
		}
<span class="fc" id="L152">	}</span>

	/**
	 * Changes the mode the the given one.
	 *
	 * @param mode The mode that is going to be activated.
	 */
	public void setMode(AbstractMode mode) {
<span class="nc" id="L160">		final MapView mv = StreetsidePlugin.getMapView();</span>
<span class="nc bnc" id="L161" title="All 4 branches missed.">		if (this.mode != null &amp;&amp; mv != null) {</span>
<span class="nc" id="L162">			mv.removeMouseListener(this.mode);</span>
<span class="nc" id="L163">			mv.removeMouseMotionListener(this.mode);</span>
<span class="nc" id="L164">			NavigatableComponent.removeZoomChangeListener(this.mode);</span>
		}
<span class="nc" id="L166">		this.mode = mode;</span>
<span class="nc bnc" id="L167" title="All 4 branches missed.">		if (mode != null &amp;&amp; mv != null) {</span>
<span class="nc" id="L168">			mv.setNewCursor(mode.cursor, this);</span>
<span class="nc" id="L169">			mv.addMouseListener(mode);</span>
<span class="nc" id="L170">			mv.addMouseMotionListener(mode);</span>
<span class="nc" id="L171">			NavigatableComponent.addZoomChangeListener(mode);</span>
<span class="nc" id="L172">			StreetsideUtils.updateHelpText();</span>
		}
<span class="nc" id="L174">	}</span>

	private static synchronized void clearInstance() {
<span class="nc" id="L177">		StreetsideLayer.instance = null;</span>
<span class="nc" id="L178">	}</span>

	/**
	 * Returns the unique instance of this class.
	 *
	 * @return The unique instance of this class.
	 */
	public static synchronized StreetsideLayer getInstance() {
<span class="nc bnc" id="L186" title="All 2 branches missed.">		if (StreetsideLayer.instance != null) {</span>
<span class="nc bnc" id="L187" title="All 2 branches missed.">			if (!MainApplication.getLayerManager().containsLayer(StreetsideLayer.instance)) {</span>
<span class="nc" id="L188">				MainApplication.getLayerManager().addLayer(StreetsideLayer.instance);</span>
			}
<span class="nc" id="L190">			return StreetsideLayer.instance;</span>
		}
<span class="nc" id="L192">		final StreetsideLayer layer = new StreetsideLayer();</span>
<span class="nc" id="L193">		StreetsideLayer.instance = layer;</span>
<span class="nc" id="L194">		layer.init();</span>
<span class="nc" id="L195">		return layer;</span>
	}

	/**
	 * @return if the unique instance of this layer is currently instantiated and added to the {@link LayerManager}
	 */
	public static boolean hasInstance() {
<span class="pc bpc" id="L202" title="3 of 4 branches missed.">		return StreetsideLayer.instance != null &amp;&amp; MainApplication.getLayerManager().containsLayer(StreetsideLayer.instance);</span>
	}

	/**
	 * Returns the {@link StreetsideData} object, which acts as the database of the
	 * Layer.
	 *
	 * @return The {@link StreetsideData} object that stores the database.
	 */
	public StreetsideData getData() {
<span class="nc" id="L212">		return data;</span>
	}

	/**
	 * Returns the n-nearest image, for n=1 the nearest one is returned, for n=2 the second nearest one and so on.
	 * The &quot;n-nearest image&quot; is picked from the list of one image from every sequence that is nearest to the currently
	 * selected image, excluding the sequence to which the selected image belongs.
	 * @param n the index for picking from the list of &quot;nearest images&quot;, beginning from 1
	 * @return the n-nearest image to the currently selected image
	 */
	public synchronized StreetsideImage getNNearestImage(final int n) {
<span class="nc bnc" id="L223" title="All 4 branches missed.">		return n &gt;= 1 &amp;&amp; n &lt;= nearestImages.length ? nearestImages[n - 1] : null;</span>
	}

	/**
	   * Returns the {@link StreetsideLocationChangeset} object, which acts as the database of the
	   * Layer.
	   *
	   * @return The {@link MapillaryData} object that stores the database.
	   */
	  public StreetsideLocationChangeset getLocationChangeset() {
<span class="nc" id="L233">	    return locationChangeset;</span>
	  }


	@Override
	public synchronized void destroy() {
		// TODO: Add destroy code for CubemapBuilder, et al.? @rrh
<span class="nc" id="L240">		StreetsideLayer.clearInstance();</span>
<span class="nc" id="L241">		setMode(null);</span>
<span class="nc" id="L242">		StreetsideRecord.getInstance().reset();</span>
<span class="nc" id="L243">		AbstractMode.resetThread();</span>
<span class="nc" id="L244">		StreetsideDownloader.stopAll();</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">		if (StreetsideMainDialog.hasInstance()) {</span>
<span class="nc" id="L246">			StreetsideMainDialog.getInstance().setImage(null);</span>
<span class="nc" id="L247">			StreetsideMainDialog.getInstance().updateImage();</span>
		}
<span class="nc" id="L249">		final MapView mv = StreetsidePlugin.getMapView();</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">		if (mv != null) {</span>
<span class="nc" id="L251">			mv.removeMouseListener(mode);</span>
<span class="nc" id="L252">			mv.removeMouseMotionListener(mode);</span>
		}
		try {
<span class="nc" id="L255">			MainApplication.getLayerManager().removeActiveLayerChangeListener(this);</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">			if (MainApplication.getLayerManager().getEditDataSet() != null) {</span>
<span class="nc" id="L257">				MainApplication.getLayerManager().getEditDataSet().removeDataSetListener(StreetsideLayer.DATASET_LISTENER);</span>
			}
<span class="nc" id="L259">		} catch (final IllegalArgumentException e) {</span>
			// TODO: It would be ideal, to fix this properly. But for the moment let's catch this, for when a listener has already been removed.
<span class="nc" id="L261">		}</span>
<span class="nc" id="L262">		super.destroy();</span>
<span class="nc" id="L263">	}</span>

	@Override
	public boolean isModified() {
		// TODO: Add cubemap modification here? @rrh
<span class="nc" id="L268">		return data.getImages().parallelStream().anyMatch(StreetsideAbstractImage::isModified);</span>
	}

	@Override
	public void setVisible(boolean visible) {
<span class="nc" id="L273">		super.setVisible(visible);</span>
<span class="nc" id="L274">		getData().getImages().parallelStream().forEach(img -&gt; img.setVisible(visible));</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">		if (MainApplication.getMap() != null) {</span>
<span class="nc" id="L276">			StreetsideFilterDialog.getInstance().refresh();</span>
		}
<span class="nc" id="L278">	}</span>

	/**
	 * Initialize the hatch pattern used to paint the non-downloaded area.
	 */
	private void createHatchTexture() {
<span class="nc" id="L284">		final BufferedImage bi = new BufferedImage(15, 15, BufferedImage.TYPE_INT_ARGB);</span>
<span class="nc" id="L285">		final Graphics2D big = bi.createGraphics();</span>
<span class="nc" id="L286">		big.setColor(StreetsideProperties.BACKGROUND.get());</span>
<span class="nc" id="L287">		final Composite comp = AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.3f);</span>
<span class="nc" id="L288">		big.setComposite(comp);</span>
<span class="nc" id="L289">		big.fillRect(0, 0, 15, 15);</span>
<span class="nc" id="L290">		big.setColor(StreetsideProperties.OUTSIDE_DOWNLOADED_AREA.get());</span>
<span class="nc" id="L291">		big.drawLine(0, 15, 15, 0);</span>
<span class="nc" id="L292">		final Rectangle r = new Rectangle(0, 0, 15, 15);</span>
<span class="nc" id="L293">		hatched = new TexturePaint(bi, r);</span>
<span class="nc" id="L294">	}</span>

	@Override
	public synchronized void paint(final Graphics2D g, final MapView mv, final Bounds box) {
<span class="nc" id="L298">		g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">		if (MainApplication.getLayerManager().getActiveLayer() == this) {</span>
			// paint remainder
<span class="nc" id="L301">			g.setPaint(hatched);</span>
<span class="nc" id="L302">			g.fill(MapViewGeometryUtil.getNonDownloadedArea(mv, data.getBounds()));</span>
		}

		// Draw the blue and red line
<span class="nc" id="L306">		synchronized (StreetsideLayer.class) {</span>
<span class="nc" id="L307">			final StreetsideAbstractImage selectedImg = data.getSelectedImage();</span>
<span class="nc bnc" id="L308" title="All 4 branches missed.">			for (int i = 0; i &lt; nearestImages.length &amp;&amp; selectedImg != null; i++) {</span>
<span class="nc bnc" id="L309" title="All 2 branches missed.">				if (i == 0) {</span>
<span class="nc" id="L310">					g.setColor(Color.RED);</span>
				} else {
<span class="nc" id="L312">					g.setColor(Color.BLUE);</span>
				}
<span class="nc" id="L314">				final Point selected = mv.getPoint(selectedImg.getMovingLatLon());</span>
<span class="nc" id="L315">				final Point p = mv.getPoint(nearestImages[i].getMovingLatLon());</span>
<span class="nc" id="L316">				g.draw(new Line2D.Double(p.getX(), p.getY(), selected.getX(), selected.getY()));</span>
			}
<span class="nc" id="L318">		}</span>

		// Draw sequence line
<span class="nc" id="L321">		g.setStroke(new BasicStroke(2));</span>
<span class="nc" id="L322">		final StreetsideAbstractImage selectedImage = getData().getSelectedImage();</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">		for (final StreetsideSequence seq : getData().getSequences()) {</span>
<span class="nc bnc" id="L324" title="All 2 branches missed.">			if (seq.getImages().contains(selectedImage)) {</span>
<span class="nc" id="L325">				g.setColor(</span>
<span class="nc bnc" id="L326" title="All 2 branches missed.">						seq.getId() == null ? StreetsideColorScheme.SEQ_IMPORTED_SELECTED : StreetsideColorScheme.SEQ_SELECTED</span>
						);
			} else {
<span class="nc" id="L329">				g.setColor(</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">						seq.getId() == null ? StreetsideColorScheme.SEQ_IMPORTED_UNSELECTED : StreetsideColorScheme.SEQ_UNSELECTED</span>
						);
			}
<span class="nc" id="L333">			g.draw(MapViewGeometryUtil.getSequencePath(mv, seq));</span>
<span class="nc" id="L334">		}</span>
<span class="nc bnc" id="L335" title="All 2 branches missed.">		for (final StreetsideAbstractImage imageAbs : data.getImages()) {</span>
<span class="nc bnc" id="L336" title="All 6 branches missed.">			if (imageAbs.isVisible() &amp;&amp; mv != null &amp;&amp; mv.contains(mv.getPoint(imageAbs.getMovingLatLon()))) {</span>
<span class="nc" id="L337">				drawImageMarker(g, imageAbs);</span>
			}
<span class="nc" id="L339">		}</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">		if (mode instanceof JoinMode) {</span>
<span class="nc" id="L341">			mode.paint(g, mv, box);</span>
		}
<span class="nc" id="L343">	}</span>

	/**
	 * Draws an image marker onto the given Graphics context.
	 * @param g the Graphics context
	 * @param img the image to be drawn onto the Graphics context
	 */
	private void drawImageMarker(final Graphics2D g, final StreetsideAbstractImage img) {
<span class="nc bnc" id="L351" title="All 4 branches missed.">		if (img == null || img.getLatLon() == null) {</span>
<span class="nc" id="L352">			Logging.warn(&quot;An image is not painted, because it is null or has no LatLon!&quot;);</span>
<span class="nc" id="L353">			return;</span>
		}
<span class="nc" id="L355">		final StreetsideAbstractImage selectedImg = getData().getSelectedImage();</span>
<span class="nc" id="L356">		final Point p = MainApplication.getMap().mapView.getPoint(img.getMovingLatLon());</span>

		// Determine colors
		final Color markerC;
		final Color directionC;
<span class="nc bnc" id="L361" title="All 4 branches missed.">		if (selectedImg != null &amp;&amp; getData().getMultiSelectedImages().contains(img)) {</span>
<span class="nc bnc" id="L362" title="All 2 branches missed.">			markerC = img instanceof StreetsideImportedImage</span>
<span class="nc" id="L363">					? StreetsideColorScheme.SEQ_IMPORTED_HIGHLIGHTED</span>
<span class="nc" id="L364">							: StreetsideColorScheme.SEQ_HIGHLIGHTED;</span>
<span class="nc bnc" id="L365" title="All 2 branches missed.">			directionC = img instanceof StreetsideImportedImage</span>
<span class="nc" id="L366">					? StreetsideColorScheme.SEQ_IMPORTED_HIGHLIGHTED_CA</span>
<span class="nc" id="L367">							: StreetsideColorScheme.SEQ_HIGHLIGHTED_CA;</span>
<span class="nc bnc" id="L368" title="All 6 branches missed.">		} else if (selectedImg != null &amp;&amp; selectedImg.getSequence() != null &amp;&amp; selectedImg.getSequence().equals(img.getSequence())) {</span>
<span class="nc bnc" id="L369" title="All 2 branches missed.">			markerC = img instanceof StreetsideImportedImage</span>
<span class="nc" id="L370">					? StreetsideColorScheme.SEQ_IMPORTED_SELECTED</span>
<span class="nc" id="L371">							: StreetsideColorScheme.SEQ_SELECTED;</span>
<span class="nc bnc" id="L372" title="All 2 branches missed.">			directionC = img instanceof StreetsideImportedImage</span>
<span class="nc" id="L373">					? StreetsideColorScheme.SEQ_IMPORTED_SELECTED_CA</span>
<span class="nc" id="L374">							: StreetsideColorScheme.SEQ_SELECTED_CA;</span>
		} else {
<span class="nc bnc" id="L376" title="All 2 branches missed.">			markerC = img instanceof StreetsideImportedImage</span>
<span class="nc" id="L377">					? StreetsideColorScheme.SEQ_IMPORTED_UNSELECTED</span>
<span class="nc" id="L378">							: StreetsideColorScheme.SEQ_UNSELECTED;</span>
<span class="nc bnc" id="L379" title="All 2 branches missed.">			directionC = img instanceof StreetsideImportedImage</span>
<span class="nc" id="L380">					? StreetsideColorScheme.SEQ_IMPORTED_UNSELECTED_CA</span>
<span class="nc" id="L381">							: StreetsideColorScheme.SEQ_UNSELECTED_CA;</span>
		}

		// Paint direction indicator
<span class="nc" id="L385">		g.setColor(directionC);</span>
<span class="nc" id="L386">		g.fillArc(p.x - StreetsideLayer.CA_INDICATOR_RADIUS, p.y - StreetsideLayer.CA_INDICATOR_RADIUS, 2 * StreetsideLayer.CA_INDICATOR_RADIUS, 2 * StreetsideLayer.CA_INDICATOR_RADIUS, (int) (90 - img.getMovingHe() - StreetsideLayer.CA_INDICATOR_ANGLE / 2d), StreetsideLayer.CA_INDICATOR_ANGLE);</span>
		// Paint image marker
<span class="nc" id="L388">		g.setColor(markerC);</span>
<span class="nc" id="L389">		g.fillOval(p.x - StreetsideLayer.IMG_MARKER_RADIUS, p.y - StreetsideLayer.IMG_MARKER_RADIUS, 2 * StreetsideLayer.IMG_MARKER_RADIUS, 2 * StreetsideLayer.IMG_MARKER_RADIUS);</span>

		// Paint highlight for selected or highlighted images
<span class="nc bnc" id="L392" title="All 4 branches missed.">		if (img.equals(getData().getHighlightedImage()) || getData().getMultiSelectedImages().contains(img)) {</span>
<span class="nc" id="L393">			g.setColor(Color.WHITE);</span>
<span class="nc" id="L394">			g.setStroke(new BasicStroke(2));</span>
<span class="nc" id="L395">			g.drawOval(p.x - StreetsideLayer.IMG_MARKER_RADIUS, p.y - StreetsideLayer.IMG_MARKER_RADIUS, 2 * StreetsideLayer.IMG_MARKER_RADIUS, 2 * StreetsideLayer.IMG_MARKER_RADIUS);</span>
		}

		// TODO: reimplement detections for Bing Metadata? RRH
<span class="nc bnc" id="L399" title="All 4 branches missed.">		if (img instanceof StreetsideImage &amp;&amp; !((StreetsideImage) img).getDetections().isEmpty()) {</span>
<span class="nc" id="L400">			final Path2D trafficSign = new Path2D.Double();</span>
<span class="nc" id="L401">			trafficSign.moveTo(p.getX() - StreetsideLayer.TRAFFIC_SIGN_SIZE / 2d, p.getY() - StreetsideLayer.TRAFFIC_SIGN_HEIGHT_3RD);</span>
<span class="nc" id="L402">			trafficSign.lineTo(p.getX() + StreetsideLayer.TRAFFIC_SIGN_SIZE / 2d, p.getY() - StreetsideLayer.TRAFFIC_SIGN_HEIGHT_3RD);</span>
<span class="nc" id="L403">			trafficSign.lineTo(p.getX(), p.getY() + 2 * StreetsideLayer.TRAFFIC_SIGN_HEIGHT_3RD);</span>
<span class="nc" id="L404">			trafficSign.closePath();</span>
<span class="nc" id="L405">			g.setColor(Color.WHITE);</span>
<span class="nc" id="L406">			g.fill(trafficSign);</span>
<span class="nc" id="L407">			g.setStroke(new BasicStroke(1));</span>
<span class="nc" id="L408">			g.setColor(Color.RED);</span>
<span class="nc" id="L409">			g.draw(trafficSign);</span>
		}
<span class="nc" id="L411">	}</span>

	@Override
	public Icon getIcon() {
<span class="nc" id="L415">		return StreetsidePlugin.LOGO.setSize(ImageSizes.LAYER).get();</span>
	}

	@Override
	public boolean isMergable(Layer other) {
<span class="nc" id="L420">		return false;</span>
	}

	@Override
	public void mergeFrom(Layer from) {
<span class="nc" id="L425">		throw new UnsupportedOperationException(</span>
				&quot;This layer does not support merging yet&quot;);
	}

	@Override
	public Action[] getMenuEntries() {
<span class="nc" id="L431">		return new Action[]{</span>
<span class="nc" id="L432">				LayerListDialog.getInstance().createShowHideLayerAction(),</span>
<span class="nc" id="L433">				LayerListDialog.getInstance().createDeleteLayerAction(),</span>
				new LayerListPopup.InfoAction(this)
		};
	}

	@Override
	public Object getInfoComponent() {
<span class="nc" id="L440">		final IntSummaryStatistics seqSizeStats = getData().getSequences().stream().mapToInt(seq -&gt; seq.getImages().size()).summaryStatistics();</span>
<span class="nc" id="L441">		return new StringBuilder(I18n.tr(&quot;Streetside layer&quot;))</span>
<span class="nc" id="L442">				.append(&quot;\n&quot;)</span>
<span class="nc" id="L443">				.append(I18n.tr(</span>
						&quot;{0} sequences, each containing between {1} and {2} images (ø {3})&quot;,
<span class="nc" id="L445">						getData().getSequences().size(),</span>
<span class="nc bnc" id="L446" title="All 2 branches missed.">						seqSizeStats.getCount() &lt;= 0 ? 0 : seqSizeStats.getMin(),</span>
<span class="nc bnc" id="L447" title="All 2 branches missed.">								seqSizeStats.getCount() &lt;= 0 ? 0 : seqSizeStats.getMax(),</span>
<span class="nc" id="L448">										seqSizeStats.getAverage()</span>
						))
<span class="nc" id="L450">				.append(&quot;\n\n&quot;)</span>
<span class="nc" id="L451">				.append(I18n.tr(</span>
						&quot;{0} imported images&quot;,
<span class="nc" id="L453">						getData().getImages().stream().filter(i -&gt; i instanceof StreetsideImportedImage).count()</span>
						))
<span class="nc" id="L455">				.append(&quot;\n+ &quot;)</span>
<span class="nc" id="L456">				.append(I18n.tr(</span>
						&quot;{0} downloaded images&quot;,
<span class="nc" id="L458">						getData().getImages().stream().filter(i -&gt; i instanceof StreetsideImage).count()</span>
						))
<span class="nc" id="L460">				.append(&quot;\n= &quot;)</span>
<span class="nc" id="L461">				.append(I18n.tr(</span>
						&quot;{0} images in total&quot;,
<span class="nc" id="L463">						getData().getImages().size()</span>
<span class="nc" id="L464">						)).toString();</span>
	}

	@Override
	public String getToolTipText() {
<span class="nc" id="L469">		return I18n.tr(&quot;{0} images in {1} sequences&quot;, getData().getImages().size(), getData().getSequences().size());</span>
	}

	@Override
	public void activeOrEditLayerChanged(ActiveLayerChangeEvent e) {
<span class="nc bnc" id="L474" title="All 2 branches missed.">		if (MainApplication.getLayerManager().getActiveLayer() == this) {</span>
<span class="nc" id="L475">			StreetsideUtils.updateHelpText();</span>
		}

<span class="nc bnc" id="L478" title="All 2 branches missed.">		if (MainApplication.getLayerManager().getEditLayer() != e.getPreviousDataLayer()) {</span>
<span class="nc bnc" id="L479" title="All 2 branches missed.">			if (MainApplication.getLayerManager().getEditLayer() != null) {</span>
<span class="nc" id="L480">				MainApplication.getLayerManager().getEditLayer().getDataSet().addDataSetListener(StreetsideLayer.DATASET_LISTENER);</span>
			}
<span class="nc bnc" id="L482" title="All 2 branches missed.">			if (e.getPreviousDataLayer() != null) {</span>
<span class="nc" id="L483">				e.getPreviousDataLayer().getDataSet().removeDataSetListener(StreetsideLayer.DATASET_LISTENER);</span>
			}
		}
<span class="nc" id="L486">	}</span>

	@Override
	public void visitBoundingBox(BoundingXYVisitor v) {
<span class="nc" id="L490">	}</span>

	/* (non-Javadoc)
	 * @see org.openstreetmap.josm.plugins.streetside.StreetsideDataListener#imagesAdded()
	 */
	@Override
	public void imagesAdded() {
		// TODO: Never used - could this be of use? @rrh
<span class="nc" id="L498">		updateNearestImages();</span>
<span class="nc" id="L499">	}</span>

	/* (non-Javadoc)
	 * @see org.openstreetmap.josm.plugins.mapillary.StreetsideDataListener#selectedImageChanged(org.openstreetmap.josm.plugins.mapillary.MapillaryAbstractImage, org.openstreetmap.josm.plugins.mapillary.MapillaryAbstractImage)
	 */
	@Override
	public void selectedImageChanged(StreetsideAbstractImage oldImage, StreetsideAbstractImage newImage) {
<span class="nc" id="L506">		updateNearestImages();</span>
<span class="nc" id="L507">	}</span>

	/**
	 * Returns the closest images belonging to a different sequence and
	 * different from the specified target image.
	 *
	 * @param target the image for which you want to find the nearest other images
	 * @param limit the maximum length of the returned array
	 * @return An array containing the closest images belonging to different sequences sorted by distance from target.
	 */
	private StreetsideImage[] getNearestImagesFromDifferentSequences(StreetsideAbstractImage target, int limit) {
<span class="nc" id="L518">		return data.getSequences().parallelStream()</span>
<span class="nc bnc" id="L519" title="All 4 branches missed.">				.filter(seq -&gt; seq.getId() != null &amp;&amp; !seq.getId().equals(target.getSequence().getId()))</span>
<span class="nc" id="L520">				.map(seq -&gt; { // Maps sequence to image from sequence that is nearest to target</span>
<span class="nc" id="L521">					final Optional&lt;StreetsideAbstractImage&gt; resImg = seq.getImages().parallelStream()</span>
<span class="nc bnc" id="L522" title="All 4 branches missed.">							.filter(img -&gt; img instanceof StreetsideImage &amp;&amp; img.isVisible())</span>
<span class="nc" id="L523">							.min(new NearestImgToTargetComparator(target));</span>
<span class="nc" id="L524">					return resImg.orElse(null);</span>
				})
<span class="nc" id="L526">				.filter(img -&gt; // Filters out images too far away from target</span>
<span class="nc bnc" id="L527" title="All 2 branches missed.">				img != null &amp;&amp;</span>
<span class="nc" id="L528">				img.getMovingLatLon().greatCircleDistance(target.getMovingLatLon())</span>
<span class="nc bnc" id="L529" title="All 2 branches missed.">				&lt; StreetsideProperties.SEQUENCE_MAX_JUMP_DISTANCE.get()</span>
						)
<span class="nc" id="L531">				.sorted(new NearestImgToTargetComparator(target))</span>
<span class="nc" id="L532">				.limit(limit)</span>
<span class="nc" id="L533">				.toArray(StreetsideImage[]::new);</span>
	}

	/**
	 * Returns the closest images belonging to a different sequence and
	 * different from the specified target image.
	 *
	 * @param target the image for which you want to find the nearest other images
	 * @param limit the maximum length of the returned array
	 * @return An array containing the closest images belonging to different sequences sorted by distance from target.
	 */
	/*private StreetsideCubemap[] getNearestCubemapsFromDifferentSequences(StreetsideAbstractImage target, int limit) {
		return data.getSequences().parallelStream()
				.filter(seq -&gt; seq.getId() != null &amp;&amp; !seq.getId().equals(target.getSequence().getId()))
				.map(seq -&gt; { // Maps sequence to image from sequence that is nearest to target
					final Optional&lt;StreetsideAbstractImage&gt; resCb = seq.getImages().parallelStream()
							.filter(cb -&gt; cb instanceof StreetsideCubemap &amp;&amp; cb.isVisible())
							.min(new NearestCbToTargetComparator(target));
					return resCb.orElse(null);
				})
				.filter(cb -&gt; // Filters out images too far away from target
				cb != null &amp;&amp;
				cb.getMovingLatLon().greatCircleDistance(target.getMovingLatLon())
				&lt; StreetsideProperties.SEQUENCE_MAX_JUMP_DISTANCE.get()
						)
				.sorted(new NearestCbToTargetComparator(target))
				.limit(limit)
				.toArray(StreetsideCubemap[]::new);
	}*/

	private synchronized void updateNearestImages() {
<span class="nc" id="L564">		final StreetsideAbstractImage selected = data.getSelectedImage();</span>
<span class="nc bnc" id="L565" title="All 2 branches missed.">		if (selected != null) {</span>
			// TODO: could this be used to pre-cache cubemaps? @rrh
<span class="nc" id="L567">			nearestImages = getNearestImagesFromDifferentSequences(selected, 2);</span>
		} else {
<span class="nc" id="L569">			nearestImages = new StreetsideImage[0];</span>
		}
<span class="nc bnc" id="L571" title="All 2 branches missed.">		if (MainApplication.isDisplayingMapView()) {</span>
<span class="nc bnc" id="L572" title="All 2 branches missed.">			StreetsideMainDialog.getInstance().redButton.setEnabled(nearestImages.length &gt;= 1);</span>
<span class="nc bnc" id="L573" title="All 2 branches missed.">			StreetsideMainDialog.getInstance().blueButton.setEnabled(nearestImages.length &gt;= 2);</span>
		}
<span class="nc bnc" id="L575" title="All 2 branches missed.">		if (nearestImages.length &gt;= 1) {</span>
<span class="nc" id="L576">			CacheUtils.downloadPicture(nearestImages[0]);</span>
			// TODO: download/pre-caches cubemaps here?
			//CacheUtils.downloadCubemap(nearestImages[0]);
<span class="nc bnc" id="L579" title="All 2 branches missed.">			if (nearestImages.length &gt;= 2) {</span>
<span class="nc" id="L580">				CacheUtils.downloadPicture(nearestImages[1]);</span>
				// TODO: download/pre-caches cubemaps here?
				//CacheUtils.downloadCubemap(nearestImages[1]);
			}
		}
<span class="nc" id="L585">	}</span>

	private static class NearestImgToTargetComparator implements Comparator&lt;StreetsideAbstractImage&gt; {
		private final StreetsideAbstractImage target;

<span class="nc" id="L590">		public NearestImgToTargetComparator(StreetsideAbstractImage target) {</span>
<span class="nc" id="L591">			this.target = target;</span>
<span class="nc" id="L592">		}</span>
		/* (non-Javadoc)
		 * @see java.util.Comparator#compare(java.lang.Object, java.lang.Object)
		 */
		@Override
		public int compare(StreetsideAbstractImage img1, StreetsideAbstractImage img2) {
<span class="nc" id="L598">			return (int) Math.signum(</span>
<span class="nc" id="L599">					img1.getMovingLatLon().greatCircleDistance(target.getMovingLatLon()) -</span>
<span class="nc" id="L600">					img2.getMovingLatLon().greatCircleDistance(target.getMovingLatLon())</span>
					);
		}
	}

	private static class NearestCbToTargetComparator implements Comparator&lt;StreetsideAbstractImage&gt; {
		private final StreetsideAbstractImage target;

<span class="nc" id="L608">		public NearestCbToTargetComparator(StreetsideAbstractImage target) {</span>
<span class="nc" id="L609">			this.target = target;</span>
<span class="nc" id="L610">		}</span>
		/* (non-Javadoc)
		 * @see java.util.Comparator#compare(java.lang.Object, java.lang.Object)
		 */
		@Override
		public int compare(StreetsideAbstractImage img1, StreetsideAbstractImage img2) {
<span class="nc" id="L616">			return (int) Math.signum(</span>
<span class="nc" id="L617">					img1.getMovingLatLon().greatCircleDistance(target.getMovingLatLon()) -</span>
<span class="nc" id="L618">					img2.getMovingLatLon().greatCircleDistance(target.getMovingLatLon())</span>
					);
		}
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>