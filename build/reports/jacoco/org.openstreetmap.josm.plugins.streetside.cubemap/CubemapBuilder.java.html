<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CubemapBuilder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">MicrosoftStreetside</a> &gt; <a href="index.source.html" class="el_package">org.openstreetmap.josm.plugins.streetside.cubemap</a> &gt; <span class="el_source">CubemapBuilder.java</span></div><h1>CubemapBuilder.java</h1><pre class="source lang-java linenums">// License: GPL. For details, see LICENSE file.
package org.openstreetmap.josm.plugins.streetside.cubemap;

import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

import org.openstreetmap.josm.plugins.streetside.StreetsideAbstractImage;
import org.openstreetmap.josm.plugins.streetside.StreetsideCubemap;
import org.openstreetmap.josm.plugins.streetside.StreetsideDataListener;
import org.openstreetmap.josm.plugins.streetside.gui.StreetsideViewerDialog;
import org.openstreetmap.josm.plugins.streetside.gui.imageinfo.StreetsideViewerHelpPopup;
import org.openstreetmap.josm.plugins.streetside.gui.imageinfo.StreetsideViewerPanel;
import org.openstreetmap.josm.plugins.streetside.utils.CubemapBox;
import org.openstreetmap.josm.plugins.streetside.utils.StreetsideProperties;
import org.openstreetmap.josm.tools.I18n;
import org.openstreetmap.josm.tools.Logging;

import javafx.scene.image.Image;
import javafx.scene.image.ImageView;

@SuppressWarnings(&quot;restriction&quot;)
public class CubemapBuilder implements ITileDownloadingTaskListener, StreetsideDataListener {

	private static CubemapBuilder instance;
	// TODO: Help Pop-up
	private StreetsideViewerHelpPopup streetsideViewerHelp;
	private StreetsideCubemap cubemap;
	protected boolean cancelled;
	private long startTime;

<span class="fc" id="L37">	private CubemapBuilder() {</span>
		// private constructor to avoid instantiation
<span class="fc" id="L39">	}</span>

	@Override
	public void imagesAdded() {
		// Do nothing
<span class="fc" id="L44">	}</span>

	@Override
	public void selectedImageChanged(StreetsideAbstractImage oldImage, StreetsideAbstractImage newImage) {
<span class="nc" id="L48">		startTime = System.currentTimeMillis();</span>

<span class="nc" id="L50">		cubemap = null;</span>
<span class="nc" id="L51">		cubemap = new StreetsideCubemap(newImage.getId(), newImage.getLatLon(), newImage.getHe());</span>
<span class="nc" id="L52">		cubemap.setCd(newImage.getCd());</span>

		// download cubemap images in different threads and then subsequently
		// set the cubeface images in JavaFX
<span class="nc" id="L56">		downloadCubemapImages(cubemap.getId());</span>
<span class="nc" id="L57">	}</span>

	public void reload(String imageId) {
<span class="nc bnc" id="L60" title="All 4 branches missed.">		if (cubemap != null &amp;&amp; imageId.equals(cubemap.getId())) {</span>
<span class="nc" id="L61">			CubemapBuilder.getInstance().getCubemap().resetFaces2TileMap();</span>
<span class="nc" id="L62">			downloadCubemapImages(imageId);</span>
		}
<span class="nc" id="L64">	}</span>

	public void downloadCubemapImages(String imageId) {

<span class="nc bnc" id="L68" title="All 2 branches missed.">		final int maxCols = StreetsideProperties.SHOW_HIGH_RES_STREETSIDE_IMAGERY.get() ? 4 : 2;</span>
<span class="nc bnc" id="L69" title="All 2 branches missed.">		final int maxRows = StreetsideProperties.SHOW_HIGH_RES_STREETSIDE_IMAGERY.get() ? 4 : 2;</span>
<span class="nc" id="L70">		final int maxThreadCount = 6 * maxCols * maxRows;</span>

<span class="nc" id="L72">		int fails = 0;</span>

<span class="nc" id="L74">		long startTime = System.currentTimeMillis();</span>

		try {

<span class="nc" id="L78">			ExecutorService pool = Executors.newFixedThreadPool(maxThreadCount);</span>
<span class="nc" id="L79">			List&lt;Callable&lt;String&gt;&gt; tasks = new ArrayList&lt;Callable&lt;String&gt;&gt;(maxThreadCount);</span>

			// launch 4-tiled (low-res) downloading tasks . . .
<span class="nc bnc" id="L82" title="All 2 branches missed.">			if (!StreetsideProperties.SHOW_HIGH_RES_STREETSIDE_IMAGERY.get()) {</span>
<span class="nc bnc" id="L83" title="All 2 branches missed.">				for (int i = 0; i &lt; CubemapUtils.NUM_SIDES; i++) {</span>
<span class="nc" id="L84">					int tileNr = 0;</span>
<span class="nc bnc" id="L85" title="All 2 branches missed.">					for (int j = 0; j &lt; maxCols; j++) {</span>
<span class="nc bnc" id="L86" title="All 2 branches missed.">						for (int k = 0; k &lt; maxRows; k++) {</span>

<span class="nc" id="L88">							String tileId = String.valueOf(imageId + CubemapUtils.getFaceNumberForCount(i)</span>
<span class="nc" id="L89">									+ Integer.valueOf(tileNr++).toString());// + Integer.valueOf(k).toString()));</span>
<span class="nc" id="L90">							tasks.add(new TileDownloadingTask(tileId));</span>
<span class="nc" id="L91">							Logging.debug(</span>
<span class="nc" id="L92">									I18n.tr(&quot;Starting tile downloading task for imageId {0}, cubeface {1}, tileNr {2}&quot;,</span>
<span class="nc" id="L93">											tileId, CubemapUtils.getFaceNumberForCount(i), String.valueOf(tileNr)));</span>
						}
					}
				}

<span class="nc" id="L98">				List&lt;Future&lt;String&gt;&gt; results = pool.invokeAll(tasks);</span>
<span class="nc bnc" id="L99" title="All 2 branches missed.">				for (Future&lt;String&gt; ff : results) {</span>

<span class="nc" id="L101">					Logging.debug(I18n.tr(&quot;Completed tile downloading task {0} in {1}&quot;, ff.get(),</span>
<span class="nc" id="L102">							CubemapUtils.msToString(startTime - System.currentTimeMillis())));</span>
<span class="nc" id="L103">				}</span>

				// launch 16-tiled (high-res) downloading tasks
<span class="nc bnc" id="L106" title="All 2 branches missed.">			} else if (StreetsideProperties.SHOW_HIGH_RES_STREETSIDE_IMAGERY.get()) {</span>
<span class="nc bnc" id="L107" title="All 2 branches missed.">				for (int i = 0; i &lt; CubemapUtils.NUM_SIDES; i++) {</span>
<span class="nc bnc" id="L108" title="All 2 branches missed.">					for (int j = 0; j &lt; maxCols; j++) {</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">						for (int k = 0; k &lt; maxRows; k++) {</span>

<span class="nc" id="L111">							String tileId = String.valueOf(imageId + CubemapUtils.getFaceNumberForCount(i)</span>
<span class="nc" id="L112">									+ String.valueOf(Integer.valueOf(j).toString() + Integer.valueOf(k).toString()));</span>
<span class="nc" id="L113">							tasks.add(new TileDownloadingTask(tileId));</span>
<span class="nc" id="L114">							Logging.debug(</span>
<span class="nc" id="L115">									I18n.tr(&quot;Starting tile downloading task for imageId {0}, cubeface {1}, tileID {2}&quot;,</span>
<span class="nc" id="L116">											imageId, CubemapUtils.getFaceNumberForCount(i), tileId));</span>
						}
					}
				}

<span class="nc" id="L121">				List&lt;Future&lt;String&gt;&gt; results = pool.invokeAll(tasks);</span>
<span class="nc bnc" id="L122" title="All 2 branches missed.">				for (Future&lt;String&gt; ff : results) {</span>
<span class="nc" id="L123">					Logging.info(I18n.tr(&quot;Completed tile downloading task {0} in {1}&quot;, ff.get(),</span>
<span class="nc" id="L124">							CubemapUtils.msToString(startTime - System.currentTimeMillis())));</span>
<span class="nc" id="L125">				}</span>
			}
<span class="nc" id="L127">		} catch (Exception ee) {</span>
<span class="nc" id="L128">			fails++;</span>
<span class="nc" id="L129">			Logging.error(&quot;Error loading tile for image {0}&quot;, imageId);</span>
<span class="nc" id="L130">			ee.printStackTrace();</span>
<span class="nc" id="L131">		}</span>

<span class="nc" id="L133">		long stopTime = System.currentTimeMillis();</span>
<span class="nc" id="L134">		long runTime = stopTime - startTime;</span>

<span class="nc" id="L136">		Logging.info(I18n.tr(&quot;Tile imagery downloading tasks completed in {0}&quot;, CubemapUtils.msToString(runTime)));</span>

<span class="nc bnc" id="L138" title="All 2 branches missed.">		if (fails &gt; 0) {</span>
<span class="nc" id="L139">			Logging.error(I18n.tr(&quot;{0} downloading tasks failed.&quot;, Integer.valueOf(fails)));</span>
		}

<span class="nc" id="L142">	}</span>

	@Override
	public void tileAdded(String tileId) {
		// determine whether four tiles have been set for each of the
		// six cubemap faces. If so, build the images for the faces
		// and set the views in the cubemap box.

<span class="nc" id="L150">		int tileCount = 0;</span>

<span class="nc bnc" id="L152" title="All 2 branches missed.">		for (int i = 0; i &lt; CubemapUtils.NUM_SIDES; i++) {</span>
<span class="nc" id="L153">			String faceNumber = CubemapUtils.getFaceNumberForCount(i);</span>
<span class="nc" id="L154">			Map&lt;String, BufferedImage&gt; faceTileImages = CubemapBuilder.getInstance().getCubemap().getFace2TilesMap()</span>
<span class="nc" id="L155">					.get(faceNumber);</span>
<span class="nc" id="L156">			tileCount += faceTileImages.values().size();</span>
		}

<span class="nc bnc" id="L159" title="All 2 branches missed.">		int maxCols = StreetsideProperties.SHOW_HIGH_RES_STREETSIDE_IMAGERY.get() ? 4 : 2;</span>
<span class="nc bnc" id="L160" title="All 2 branches missed.">		int maxRows = StreetsideProperties.SHOW_HIGH_RES_STREETSIDE_IMAGERY.get() ? 4 : 2;</span>

<span class="nc bnc" id="L162" title="All 2 branches missed.">		if (tileCount == (CubemapUtils.NUM_SIDES * maxCols * maxRows)) {</span>
<span class="nc" id="L163">			Logging.info(I18n.tr(&quot;{0} tile images ready for building cumbemap faces for cubemap {0}&quot;, tileCount,</span>
<span class="nc" id="L164">					CubemapBuilder.getInstance().getCubemap().getId()));</span>

<span class="nc" id="L166">			buildCubemapFaces();</span>
		} else {
<span class="nc" id="L168">			Logging.info(I18n.tr(&quot;{0} tile images received for cubemap {1}&quot;, Integer.valueOf(tileCount).toString(),</span>
<span class="nc" id="L169">					CubemapBuilder.getInstance().getCubemap().getId()));</span>
		}
<span class="nc" id="L171">	}</span>

	private void buildCubemapFaces() {
<span class="nc" id="L174">		CubemapBox cmb = StreetsideViewerDialog.getInstance().getStreetsideViewerPanel().getCubemapBox();</span>
<span class="nc" id="L175">		ImageView[] views = cmb.getViews();</span>

<span class="nc bnc" id="L177" title="All 2 branches missed.">		final int maxCols = StreetsideProperties.SHOW_HIGH_RES_STREETSIDE_IMAGERY.get() ? 4 : 2;</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">		final int maxRows = StreetsideProperties.SHOW_HIGH_RES_STREETSIDE_IMAGERY.get() ? 4 : 2;</span>

<span class="nc" id="L180">		Image finalImages[] = new Image[CubemapUtils.NUM_SIDES];</span>

		// build 4-tiled cubemap faces and crop buffers
<span class="nc bnc" id="L183" title="All 2 branches missed.">		if (!StreetsideProperties.SHOW_HIGH_RES_STREETSIDE_IMAGERY.get()) {</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">			for (int i = 0; i &lt; CubemapUtils.NUM_SIDES; i++) {</span>

<span class="nc" id="L186">				Map&lt;String, BufferedImage&gt; tileImages = CubemapBuilder.getInstance().getCubemap().getFace2TilesMap()</span>
<span class="nc" id="L187">						.get(CubemapUtils.getFaceNumberForCount(i));</span>
<span class="nc" id="L188">				BufferedImage[] faceTileImages = new BufferedImage[maxCols * maxRows];</span>

<span class="nc bnc" id="L190" title="All 2 branches missed.">				for (int j = 0; j &lt; (maxCols * maxRows); j++) {</span>
<span class="nc" id="L191">					String tileId = String.valueOf(getCubemap().getId() + CubemapUtils.getFaceNumberForCount(i)</span>
<span class="nc" id="L192">							+ Integer.valueOf(j).toString());</span>
<span class="nc" id="L193">					BufferedImage currentTile = tileImages.get(tileId);</span>

<span class="nc" id="L195">					faceTileImages[j] = currentTile;</span>
				}

<span class="nc" id="L198">				BufferedImage finalImg = GraphicsUtils.buildMultiTiledCubemapFaceImage(faceTileImages);</span>

				// rotate top cubeface 180 degrees - misalignment workaround
<span class="nc bnc" id="L201" title="All 2 branches missed.">				if (i == 4) {</span>
<span class="nc" id="L202">					finalImg = GraphicsUtils.rotateImage(finalImg);</span>
				}
<span class="nc" id="L204">				finalImages[i] = GraphicsUtils.convertBufferedImage2JavaFXImage(finalImg);</span>
			}
			// build 16-tiled cubemap faces and crop buffers
<span class="nc bnc" id="L207" title="All 2 branches missed.">		} else if (StreetsideProperties.SHOW_HIGH_RES_STREETSIDE_IMAGERY.get()) {</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">			for (int i = 0; i &lt; CubemapUtils.NUM_SIDES; i++) {</span>

<span class="nc" id="L210">				int tileCount = 0;</span>

<span class="nc" id="L212">				Map&lt;String, Map&lt;String, BufferedImage&gt;&gt; face2TilesMap = CubemapBuilder.getInstance().getCubemap()</span>
<span class="nc" id="L213">						.getFace2TilesMap();</span>
<span class="nc" id="L214">				Map&lt;String, BufferedImage&gt; tileImages = face2TilesMap.get(CubemapUtils.getFaceNumberForCount(i));</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">				BufferedImage[] faceTileImages = new BufferedImage[StreetsideProperties.SHOW_HIGH_RES_STREETSIDE_IMAGERY</span>
<span class="nc" id="L216">						.get() ? 16 : 4];</span>

<span class="nc bnc" id="L218" title="All 2 branches missed.">				for (int j = 0; j &lt; maxCols; j++) {</span>
<span class="nc bnc" id="L219" title="All 2 branches missed.">					for (int k = 0; k &lt; maxRows; k++) {</span>
<span class="nc" id="L220">						String tileId = String.valueOf(getCubemap().getId() + CubemapUtils.getFaceNumberForCount(i)</span>
<span class="nc" id="L221">								+ CubemapUtils.convertDoubleCountNrto16TileNr(</span>
<span class="nc" id="L222">										String.valueOf(Integer.valueOf(j).toString() + Integer.valueOf(k).toString())));</span>
<span class="nc" id="L223">						BufferedImage currentTile = tileImages.get(tileId);</span>
<span class="nc" id="L224">						faceTileImages[tileCount++] = currentTile;</span>
					}
				}
<span class="nc" id="L227">				BufferedImage finalImg = GraphicsUtils.buildMultiTiledCubemapFaceImage(faceTileImages);</span>
				// rotate top cubeface 180 degrees - misalignment workaround
<span class="nc bnc" id="L229" title="All 2 branches missed.">				if (i == 4) {</span>
<span class="nc" id="L230">					finalImg = GraphicsUtils.rotateImage(finalImg);</span>
				}
<span class="nc" id="L232">				finalImages[i] = GraphicsUtils.convertBufferedImage2JavaFXImage(finalImg);</span>
			}
		}

<span class="nc bnc" id="L236" title="All 2 branches missed.">		for (int i = 0; i &lt; CubemapUtils.NUM_SIDES; i++) {</span>
<span class="nc" id="L237">			views[i].setImage(finalImages[i]);</span>
		}

<span class="nc" id="L240">		StreetsideViewerDialog.getInstance().getStreetsideViewerPanel().revalidate();</span>
<span class="nc" id="L241">		StreetsideViewerDialog.getInstance().getStreetsideViewerPanel().repaint();</span>
<span class="nc" id="L242">		StreetsideViewerPanel.getThreeSixtyDegreeViewerPanel().revalidate();</span>
<span class="nc" id="L243">		StreetsideViewerPanel.getThreeSixtyDegreeViewerPanel().repaint();</span>

<span class="nc" id="L245">		long endTime = System.currentTimeMillis();</span>
<span class="nc" id="L246">		long runTime = endTime - startTime;</span>
<span class="nc" id="L247">		Logging.info(I18n.tr(&quot;Completed downloading, assembling and setting cubemap imagery for cubemap {0} in {1}&quot;,</span>
<span class="nc" id="L248">				cubemap.getId(), CubemapUtils.msToString(runTime)));</span>
<span class="nc" id="L249">	}</span>

	/**
	 * @return the cubemap
	 */
	public synchronized StreetsideCubemap getCubemap() {
<span class="nc" id="L255">		return cubemap;</span>
	}

	/**
	 * @param cubemap
	 *            the cubemap to set
	 */
	public static void setCubemap(StreetsideCubemap cubemap) {
<span class="nc" id="L263">		CubemapBuilder.getInstance().cubemap = cubemap;</span>
<span class="nc" id="L264">	}</span>

	public static CubemapBuilder getInstance() {
<span class="fc bfc" id="L267" title="All 2 branches covered.">		if (instance == null) {</span>
<span class="fc" id="L268">			instance = new CubemapBuilder();</span>
		}
<span class="fc" id="L270">		return instance;</span>
	}

	/**
	 * @return true, iff the singleton instance is present
	 */
	public static boolean hasInstance() {
<span class="nc bnc" id="L277" title="All 2 branches missed.">		return CubemapBuilder.instance != null;</span>
	}

	/**
	 * Destroys the unique instance of the class.
	 */
	public static synchronized void destroyInstance() {
<span class="nc" id="L284">		CubemapBuilder.instance = null;</span>
<span class="nc" id="L285">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>