<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CacheUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">msstreetside</a> &gt; <a href="index.source.html" class="el_package">org.openstreetmap.josm.plugins.streetside.cache</a> &gt; <span class="el_source">CacheUtils.java</span></div><h1>CacheUtils.java</h1><pre class="source lang-java linenums">// License: GPL. For details, see LICENSE file.
package org.openstreetmap.josm.plugins.streetside.cache;


import java.io.IOException;

import org.openstreetmap.josm.data.cache.CacheEntry;
import org.openstreetmap.josm.data.cache.CacheEntryAttributes;
import org.openstreetmap.josm.data.cache.ICachedLoaderListener;
import org.openstreetmap.josm.plugins.streetside.StreetsideImage;
import org.openstreetmap.josm.plugins.streetside.cubemap.CubemapBuilder;
import org.openstreetmap.josm.tools.Logging;

/**
* Utility methods for working with cache.
*
* @author nokutu
*
*/
public final class CacheUtils {

<span class="nc" id="L22">private static IgnoreDownload ignoreDownload = new IgnoreDownload();</span>

/** Picture quality */
<span class="nc" id="L25">public enum PICTURE {</span>
 /** Thumbnail quality picture (320 p) */
<span class="nc" id="L27"> THUMBNAIL,</span>
 /** Full quality picture (2048 p) */
<span class="nc" id="L29"> FULL_IMAGE,</span>
 /** Both of them */
<span class="nc" id="L31"> BOTH,</span>
 /** Streetside cubemap */
<span class="nc" id="L33"> CUBEMAP</span>
}

<span class="nc" id="L36">private CacheUtils() {</span>
 // Private constructor to avoid instantiation
<span class="nc" id="L38">}</span>

/**
* Downloads the the thumbnail and the full resolution picture of the given
* image. Does nothing if it is already in cache.
*
* @param img
*          The image whose picture is going to be downloaded.
*/
public static void downloadPicture(StreetsideImage img) {
<span class="nc" id="L48"> downloadPicture(img, PICTURE.BOTH);</span>
<span class="nc" id="L49">}</span>

/**
* Downloads the the thumbnail and the full resolution picture of the given
* image. Does nothing if it is already in cache.
*
* @param img
*          The image whose picture is going to be downloaded.
*/
public static void downloadCubemap(StreetsideImage cm) {
	// TODO: causes errors. Analyze @rrh
	//downloadPicture(cm, PICTURE.CUBEMAP);
<span class="nc" id="L61">}</span>

/**
* Downloads the picture of the given image. Does nothing when it is already
* in cache.
*
* @param img
*          The image to be downloaded.
* @param pic
*          The picture type to be downloaded (full quality, thumbnail or
*          both.)
*/
public static void downloadPicture(StreetsideImage img, PICTURE pic) {
<span class="nc bnc" id="L74" title="All 4 branches missed."> switch (pic) {</span>
   case BOTH:
<span class="nc bnc" id="L76" title="All 2 branches missed.">     if (new StreetsideCache(img.getId(), StreetsideCache.Type.THUMBNAIL).get() == null)</span>
<span class="nc" id="L77">       submit(img.getId(), StreetsideCache.Type.THUMBNAIL, ignoreDownload);</span>
<span class="nc bnc" id="L78" title="All 2 branches missed.">     if (new StreetsideCache(img.getId(), StreetsideCache.Type.FULL_IMAGE).get() == null)</span>
<span class="nc" id="L79">       submit(img.getId(), StreetsideCache.Type.FULL_IMAGE, ignoreDownload);</span>
     break;
   case THUMBNAIL:
<span class="nc" id="L82">     submit(img.getId(), StreetsideCache.Type.THUMBNAIL, ignoreDownload);</span>
<span class="nc" id="L83">     break;</span>
   case FULL_IMAGE:
   // TODO: is this still useful? @rrh
   case CUBEMAP:
<span class="nc bnc" id="L87" title="All 2 branches missed.">	   if(img.getId()==null) {</span>
<span class="nc" id="L88">		   Logging.error(&quot;Download cancelled. Image id is null.&quot;);</span>
	   } else {
<span class="nc" id="L90">		   CubemapBuilder.getInstance().downloadCubemapImages(img.getId());</span>
	   }
<span class="nc" id="L92">	   break;</span>
   default:
<span class="nc" id="L94">     submit(img.getId(), StreetsideCache.Type.FULL_IMAGE, ignoreDownload);</span>
     break;
 }
<span class="nc" id="L97">}</span>

/**
* Downloads the picture of the given image. Does nothing when it is already
* in cache.
*
* @param cm
*          The cubemap to be downloaded.
* @param pic
*          The picture type to be downloaded (full quality, thumbnail, both, or cubemap.)
*/
/*public static void downloadCubemapFront(StreetsideImage cm, PICTURE pic) {
 switch (pic) {
   case CUBEMAP:
	   for (int i = 0; i &lt; 6; i++) {
			for (int j = 0; j &lt; 4; j++) {
				for (int k = 0; k &lt; 4; k++) {
					String cubeface = CubemapUtils.getFaceNumberForCount(i);
					String tileNr = CubemapUtils.rowCol2StreetsideCellAddressMap
							.get(Integer.toString(j) + Integer.toString(k));
					long tileId = Long.parseLong(cm.getId() + cubeface + tileNr);

					submit(cm.getId(), StreetsideCache.Type.CUBEMAP_FRONT, ignoreDownload);

				}
			}
		}
	   break;
   default:
     submit(cm.getId(), StreetsideCache.Type.CUBEMAP_FRONT, ignoreDownload);
     break;
 }
}*/

/*public static void downloadCubemapRight(StreetsideImage cm, PICTURE pic) {
	 switch (pic) {
	   case CUBEMAP:
		   for (int i = 0; i &lt; 6; i++) {
				for (int j = 0; j &lt; 4; j++) {
					for (int k = 0; k &lt; 4; k++) {
						String cubeface = CubemapUtils.getFaceNumberForCount(i);
						String tileNr = CubemapUtils.rowCol2StreetsideCellAddressMap
								.get(Integer.toString(j) + Integer.toString(k));
						long tileId = Long.parseLong(cm.getId() + cubeface + tileNr);

						submit(cm.getId(), StreetsideCache.Type.CUBEMAP_RIGHT, ignoreDownload);

					}
				}
			}
		   break;
	   default:
	     submit(cm.getId(), StreetsideCache.Type.CUBEMAP_RIGHT, ignoreDownload);
	     break;
	 }
	}*/

/*public static void downloadCubemapBack(StreetsideImage cm, PICTURE pic) {
	 switch (pic) {
	   case CUBEMAP:
		   for (int i = 0; i &lt; 6; i++) {
				for (int j = 0; j &lt; 4; j++) {
					for (int k = 0; k &lt; 4; k++) {
						String cubeface = CubemapUtils.getFaceNumberForCount(i);
						String tileNr = CubemapUtils.rowCol2StreetsideCellAddressMap
								.get(Integer.toString(j) + Integer.toString(k));
						long tileId = Long.parseLong(cm.getId() + cubeface + tileNr);

						submit(cm.getId(), StreetsideCache.Type.CUBEMAP_BACK, ignoreDownload);

					}
				}
			}
		   break;
	   default:
	     submit(cm.getId(), StreetsideCache.Type.CUBEMAP_BACK, ignoreDownload);
	     break;
	 }
	}*/

/*public static void downloadCubemapLeft(StreetsideImage cm, PICTURE pic) {
	 switch (pic) {
	   case CUBEMAP:
		   for (int i = 0; i &lt; 6; i++) {
				for (int j = 0; j &lt; 4; j++) {
					for (int k = 0; k &lt; 4; k++) {
						String cubeface = CubemapUtils.getFaceNumberForCount(i);
						String tileNr = CubemapUtils.rowCol2StreetsideCellAddressMap
								.get(Integer.toString(j) + Integer.toString(k));
						long tileId = Long.parseLong(cm.getId() + cubeface + tileNr);

						submit(cm.getId(), StreetsideCache.Type.CUBEMAP_LEFT, ignoreDownload);

					}
				}
			}
		   break;
	   default:
	     submit(cm.getId(), StreetsideCache.Type.CUBEMAP_LEFT, ignoreDownload);
	     break;
	 }
	}*/

/*public static void downloadCubemapUp(StreetsideImage cm, PICTURE pic) {
	 switch (pic) {
	   case CUBEMAP:
		   for (int i = 0; i &lt; 6; i++) {
				for (int j = 0; j &lt; 4; j++) {
					for (int k = 0; k &lt; 4; k++) {
						String cubeface = CubemapUtils.getFaceNumberForCount(i);
						String tileNr = CubemapUtils.rowCol2StreetsideCellAddressMap
								.get(Integer.toString(j) + Integer.toString(k));
						long tileId = Long.parseLong(cm.getId() + cubeface + tileNr);

						submit(cm.getId(), StreetsideCache.Type.CUBEMAP_UP, ignoreDownload);

					}
				}
			}
		   break;
	   default:
	     submit(cm.getId(), StreetsideCache.Type.CUBEMAP_UP, ignoreDownload);
	     break;
	 }
	}*/

/*public static void downloadCubemapDown(StreetsideImage cm, PICTURE pic) {
	 switch (pic) {
	   case CUBEMAP:
		   for (int i = 0; i &lt; 6; i++) {
				for (int j = 0; j &lt; 4; j++) {
					for (int k = 0; k &lt; 4; k++) {
						String cubeface = CubemapUtils.getFaceNumberForCount(i);
						String tileNr = CubemapUtils.rowCol2StreetsideCellAddressMap
								.get(Integer.toString(j) + Integer.toString(k));
						long tileId = Long.parseLong(cm.getId() + cubeface + tileNr);

						submit(cm.getId(), StreetsideCache.Type.CUBEMAP_DOWN, ignoreDownload);

					}
				}
			}
		   break;
	   default:
	     submit(cm.getId(), StreetsideCache.Type.CUBEMAP_DOWN, ignoreDownload);
	     break;
	 }
	}*/

/**
* Requests the picture with the given key and quality and uses the given
* listener.
*
* @param key
*          The key of the picture to be requested.
* @param type
*          The quality of the picture to be requested.
* @param lis
*          The listener that is going to receive the picture.
*/
public static void submit(String key, StreetsideCache.Type type,
   ICachedLoaderListener lis) {
 try {
<span class="nc" id="L260">   new StreetsideCache(key, type).submit(lis, false);</span>
<span class="nc" id="L261"> } catch (IOException e) {</span>
<span class="nc" id="L262">   Logging.error(e);</span>
<span class="nc" id="L263"> }</span>
<span class="nc" id="L264">}</span>

<span class="nc" id="L266">private static class IgnoreDownload implements ICachedLoaderListener {</span>

 @Override
 public void loadingFinished(CacheEntry arg0, CacheEntryAttributes arg1, LoadResult arg2) {
   // Ignore download
<span class="nc" id="L271"> }</span>
}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>